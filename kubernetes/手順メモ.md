# 手順メモ

## ローカルでアプリの動作を確認する。

当docker-comopse.yamlが存在しているディレクトリで以下のコマンドを  
実行すると、ローカルでアプリの動作を確認することができます。  
詳しくはdocker-compose.ymlファイルのコメントを見てください。  

## minikubeで動作を確認する。
### ローカルでdockerコンテナをdocker-composeではなく起動して動作確認する
Dockerfileからイメージを作成してDockerHubにイメージをpushする必要がある。  
まずはDockerhubにアカウントを作ってログインをしよう。  
二箇所のDockerfileのあるディレクトリに移動して以下のコマンドを実行します。  
kambeの文字列はそれぞれご自身のdockerhubのユーザー名にしてください。
```
docker build --tag=kambe/minikubereact:1.0 .
docker build --tag=kambe/minikubedjango:1.1 .
```

一旦今作ったイメージから起動して問題なくローカルで動作するかを確認してみましょう。  
docker-compose.ymlのあるディレクトリに移動します。
```
docker run --detach -p 3306:3306 --env-file ./mysql/.env --name mysql mysql:5.7 

docker run --detach -p 3000:3000 --env-file ./react/.env --name react kambe/minikubereact:1.1

docker ps 
docker inspect mysqlのコンテナID
出力されたNetworksのbridgeのIPAddressを./python/.envのDATABASE_HOSTに貼り付け

docker run --detach -p 8000:8000 --env-file ./python/.env --name python -i -t kambe/minikubedjango:1.1
docker ps 
docker exec -it 上記のコマンドで作成したpythonコンテナID bash
python manage.py migrate
```
作成した3つのコンテナはdocker stop コンテナID をしてからdocker rm コンテナID で削除しよう
そして./python/.envそしてファイルのDATABASE_HOSTにも、元のenvのDATABASE_HOST=dbとしておこう

動作確認ができたら、作成したイメージをdockerhubにpushしよう
```
docker push kambe/minikubedjango:1.1
docker push kambe/minikubereact:1.0
```
### minikubeで使用できるようなkubernetesのマニフェストyamlから作成

kubernetes/minikube/のディレクトリへ移動します。

ingressを有効化します。
```
minikube addons list
minikube addons enable ingress
minikube addons list
ingressがenableであることを確認します。
```

まずはデータベースの作成と接続確認
作成
```
kubectl apply -f configmap.yaml
kubectl apply -f db_deployment.yaml
kubectl apply -f db_service.yaml
```
接続確認
```
kubectl run mysql-client --image=mysql:5.7 -it --rm --restart=Never -- /bin/bash
mysql -h db-clusterip -uroot -p -e 'SHOW databases;'
パスワードはconfigmapのMYSQL_ROOT_PASSWORD
exit
exitしても削除されない場合は kubectl delete pod mysql-client
```



次にingressの作成
CORSやエンドポイントを決めるため作成します。(本来はあとから作成するものですが、minikubeはドメイン名を決定できないため。)
```
kubectl apply -f react_ingress.yaml
kubectl apply -f django_ingress.yaml
```
別なターミナルで以下のコマンドを実行しておくと、現在の作成状況がわかって便利です。
```
watch 'kubectl get pod,svc,ingress -o wide'
```

以下の2ファイルの環境変数にingressのADDRESSのIPアドレスを設定します。
react_deployment.yaml
django_deployment.yaml

マイグレーションの実行
```
kubectl apply -f django_migratejob.yaml
```

次にdjangoの作成と接続確認
作成
```
kubectl apply -f django_deployment.yaml
kubectl apply -f django_service.yaml
```
接続確認
ブラウザから接続確認
http://ingressのADDRESSのIPアドレス/admin
画面が表示されればOK



次にreactの作成と接続確認
```
kubectl apply -f react_deployment.yaml
kubectl apply -f react_service.yaml
```

接続確認
ブラウザから接続確認
http://ingressのADDRESSのIPアドレス/
適当なユーザーを作成して、ノートを新規登録してみる

DBに反映されているか確認
kubectl run mysql-client --image=mysql:5.7 -it --rm --restart=Never -- /bin/bash
-u と -pなどはconfigmapの記載のとおりです  
mysql -h db-clusterip -u django -p
use django-db;
select * from api_note;
データベースに内容が反映されていることを確認する。
exit
exit
exitしても削除されない場合は kubectl delete pod mysql-client

minikubeでの動作確認が完了！！

クリーンアップ
まるっとコピーしてターミナルで実行するとすべて削除できます。
もし成功しない場合は削除されていないリソースのみ再度実行してみてください。
kubectl delete -f configmap.yaml
kubectl delete -f db_deployment.yaml
kubectl delete -f db_service.yaml
kubectl delete -f react_ingress.yaml
kubectl delete -f django_ingress.yaml
kubectl delete -f django_migratejob.yaml
kubectl delete -f django_deployment.yaml
kubectl delete -f django_service.yaml
kubectl delete -f react_deployment.yaml
kubectl delete -f react_service.yaml

おまけ
curlで動作確認したい場合は以下を参考にしてください
kubectl run --restart Never --image curlimages/curl:7.68.0 -it --rm curl sh
exitしても削除されない場合は kubectl delete pod curl












kubectl get pod
djangoのdeploymentから作成されたpod名を確認
kubectl exec -it deploymentから作成されたpod名 bash
python manage.py migrate
python manage.py createsuperuser
任意のユーザー名、パスワードでsuperuserを作成する。
exit
echo $(minikube service django-clusterip --url)/admin

次にdbとdjangoの接続確認
adminページからデータを追加するとdbにも反映されることを確認する。






kubectl delete -f ingress.yaml
kubectl delete -f react_service.yaml
kubectl delete -f react_deployment.yaml



kubectl delete -f django_service.yaml
kubectl delete -f django_deployment.yaml


kubectl delete -f configmap.yaml
kubectl delete -f db_deployment.yaml
kubectl delete -f db_service.yaml


